## 编程作业: 期末考试

## 编程题＃1：含k个3的数

[来源: POJ](http://pkuic.openjudge.cn/2013finaltest/01/) (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)

**注意： 总时间限制: 1000ms 内存限制: 65536kB**

### 描述

输入二个正整数m 和 k，其中1 < m < 100000，1 < k <5 ，判断m 能否被19整除，且恰好含有k个3，如果满足条件，则输出YES，否则，输出NO。

例如，输入：

43833 3

满足条件，输出YES

如果输入

39331 3

尽管有3个3，但不能被19整除，也不满足条件，应输出NO

### 输入

m 和 k 的值，空格间隔

### 输出

满足条件时输出 YES，不满足时输出 NO

### 样例输入

```
43833 3
```

### 样例输出

```
YES
```



## 编程题＃2：字符串中次数第2多的字母

[来源: POJ](http://pkuic.openjudge.cn/2013finaltest/05) (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)

**注意： 总时间限制: 1000ms 内存限制: 65536kB**

### 描述

输入一串长度不超过500个符号的字符串，输出在串中出现第2多的英语字母(大小写字母认为相同)和次数（如果串中有其它符号，则忽略不考虑）。如果有多个字母的次数都是第2多，则按串中字母出现的顺序输出第1个。

例 ab&dcAab&c9defgb

这里，a 和 b都出现3次，c和d都出现2次，e、f 和 g 各出现1次，其中的符号&和9均忽略不考虑。因此，出现第2多的应该是 c 和 d，但是 d 开始出现的位置在 c 的前面，因此，输出为

D+d:2

(假定在字符串中，次数第2多的字母总存在)

### 输入

一个字符串

### 输出

大写字母+小写字母:个数

### 样例输入

```
1








ab&dcAab&c9defgb






```

### 样例输出

```
D+d:2
```



## 编程题＃3：运算符判定

[来源: POJ](http://pkuic.openjudge.cn/2013finaltest/08/) (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)

**注意： 总时间限制: 1000ms 内存限制: 65536kB**

### 描述

两个整数 a 和 b 运算后得到结果 c。表示为：a ? b = c，其中，？可能是加法 +，减法 -，乘法 *，整除 / 或 取余 %。请根据输入的 a,b,c 的值，确定运算符。如果某种运算成立，则输出相应的运算符，如果任何运算都不成立，则输出 error.

例如：

输入：

3,4,5

输出：

error

若输入：

3,4,3

则输出：

%

### 输入

a b和 c 的值在意行内输入，以逗号间隔

### 输出

五个运算符之一或 error

### 样例输入

```
6,7,13
```

### 样例输出

```
+
```



## 编程题＃4：寻找平面上的极大点

[来源: POJ](http://pkuic.openjudge.cn/2013finaltest/10/) (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)

**注意： 总时间限制: 1000ms 内存限制: 65536kB**

### 描述

在一个平面上，如果有两个点(x,y),(a,b),如果说(x,y)支配了(a,b)，这是指x>=a,y>=b;

用图形来看就是(a,b)坐落在以(x,y)为右上角的一个无限的区域内。

给定n个点的集合，一定存在若干个点，它们不会被集合中的任何一点所支配，这些点叫做极大值点。

编程找出所有的极大点，按照x坐标由小到大，输出极大点的坐标。

本题规定：n不超过100，并且不考虑点的坐标为负数的情况。

### 输入

输入包括两行，第一行是正整数n，表示是点数，第二行包含n个点的坐标，坐标值都是整数，坐标范围从0到100，输入数据中不存在坐标相同的点。

### 输出

按x轴坐标最小到大的顺序输出所有极大点。

输出格式为:(x1,y1),(x2,y2),...(xk,yk)

**注意：输出的每个点之间有","分隔,最后一个点之后没有",",少输出和多输出都会被判错**

### 样例输入

```
1
2








5

1 2 2 2 3 1 2 3 1 4






```

### 样例输出

```
(1,4),(2,3),(3,1)
```

### 提示

![img](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/XSDoISEXEeWP0grpjIbQnw_27bcc87da7efe4c224c1a0f48e0b1a1a_Screen-Shot-2015-07-02-at-5.06.20-PM.png?expiry=1513814400000&hmac=jfDO8uGs3T_wgyzNfsyeB2ZBfUIPjiywKpdK6wMcAtc)



## 编程题＃5：走出迷宫

[来源: POJ](http://pkuic.openjudge.cn/2013finaltest/18/) (Coursera声明：在POJ上完成的习题将不会计入Coursera的最后成绩。)

**注意： 总时间限制: 1000ms 内存限制: 65536kB**

### 描述

当你站在一个迷宫里的时候，往往会被错综复杂的道路弄得失去方向感，如果你能得到迷宫地图，事情就会变得非常简单。

假设你已经得到了一个n*m的迷宫的图纸，请你找出从起点到出口的最短路。

### 输入

第一行是两个整数n和m(1 <= n,m <= 100)，表示迷宫的行数和列数。

接下来n行，每行一个长为m的字符串，表示整个迷宫的布局。字符'.'表示空地，'#'表示墙，'S'表示起点,'T'表示出口。

### 输出

输出从起点到出口最少需要走的步数。(你不能起出迷宫外)

### 样例输入

```
3 3
S#T
.#.
...
```

### 样例输出

```
6
```
### 解题思路

这道题我还是做了很久的，现在整理一下思路吧。在博客看到一些更高级的方法，要用到堆栈好像，不过还没学，就只能用递归硬解了。

这里用到的递归应该很好理解，每一位置都可能有至多四种走法（上下左右），所以用一个 `move` 函数来表示移动**一步**，这样就形成了 `move` 的递归调用

```c++
void move(...)
{
  	if (...)
      	return;
  	if (...)
      	move(...);
  	if (...)
      	move(...);
  	...
}
```

找到最短路径的中心思想就是：遍历所有可能的路径，然后比较找出最短路径的步数。我们用一个和地图同样大小的矩阵 `int Step[n][m]` 来存储步数，每走一步就在矩阵中记录当前步数 `int step`，一直走到终点我们就得到了最终的步数 `Step[endRow][endCol]`。

显然，计算出所有步数之后再来比较是很难实现的，因为我们事先不知道有多少种走法。因此在走的每一步我们都进行比较，如果步数更少则覆盖，如果步数更多就不走。这样到函数调用结束的时候，出口位置保存的就是最短路径的步数。

到这里都理解了的话程序就很好写了，最后一个难点就是条件判断，之怎样的判断可以确保不往回走，确保所有可能的最短路径都走遍，还有前面降到的步数的比较等等。PS. 这里我写的条件又臭又长，暂时我还没有更简短的写法